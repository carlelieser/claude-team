{"version":3,"file":"context.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.46.4/node_modules/svelte/src/internal/shared/utils.js","../../../../../../node_modules/.pnpm/svelte@5.46.4/node_modules/svelte/src/internal/shared/errors.js","../../../../../../node_modules/.pnpm/svelte@5.46.4/node_modules/svelte/src/escaping.js","../../../../../../node_modules/.pnpm/svelte@5.46.4/node_modules/svelte/src/internal/server/context.js"],"sourcesContent":["// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var index_of = Array.prototype.indexOf;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\nexport var is_extensible = Object.isExtensible;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/**\n * TODO replace with Promise.withResolvers once supported widely enough\n * @template [T=void]\n */\nexport function deferred() {\n\t/** @type {(value: T) => void} */\n\tvar resolve;\n\n\t/** @type {(reason: any) => void} */\n\tvar reject;\n\n\t/** @type {Promise<T>} */\n\tvar promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\n\t// @ts-expect-error\n\treturn { promise, resolve, reject };\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V | (() => V)} fallback\n * @param {boolean} [lazy]\n * @returns {V}\n */\nexport function fallback(value, fallback, lazy = false) {\n\treturn value === undefined\n\t\t? lazy\n\t\t\t? /** @type {() => V} */ (fallback)()\n\t\t\t: /** @type {V} */ (fallback)\n\t\t: value;\n}\n\n/**\n * When encountering a situation like `let [a, b, c] = $derived(blah())`,\n * we need to stash an intermediate value that `a`, `b`, and `c` derive\n * from, in case it's an iterable\n * @template T\n * @param {ArrayLike<T> | Iterable<T>} value\n * @param {number} [n]\n * @returns {Array<T>}\n */\nexport function to_array(value, n) {\n\t// return arrays unchanged\n\tif (Array.isArray(value)) {\n\t\treturn value;\n\t}\n\n\t// if value is not iterable, or `n` is unspecified (indicates a rest\n\t// element, which means we're not concerned about unbounded iterables)\n\t// convert to an array with `Array.from`\n\tif (n === undefined || !(Symbol.iterator in value)) {\n\t\treturn Array.from(value);\n\t}\n\n\t// otherwise, populate an array with `n` values\n\n\t/** @type {T[]} */\n\tconst array = [];\n\n\tfor (const element of value) {\n\t\tarray.push(element);\n\t\tif (array.length === n) break;\n\t}\n\n\treturn array;\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Cannot use `%name%(...)` unless the `experimental.async` compiler option is `true`\n * @param {string} name\n * @returns {never}\n */\nexport function experimental_async_required(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`experimental_async_required\\nCannot use \\`${name}(...)\\` unless the \\`experimental.async\\` compiler option is \\`true\\`\\nhttps://svelte.dev/e/experimental_async_required`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/experimental_async_required`);\n\t}\n}\n\n/**\n * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead\n * @returns {never}\n */\nexport function invalid_default_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_default_snippet\\nCannot use \\`{@render children(...)}\\` if the parent component uses \\`let:\\` directives. Consider using a named snippet instead\\nhttps://svelte.dev/e/invalid_default_snippet`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/invalid_default_snippet`);\n\t}\n}\n\n/**\n * A snippet function was passed invalid arguments. Snippets should only be instantiated via `{@render ...}`\n * @returns {never}\n */\nexport function invalid_snippet_arguments() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_snippet_arguments\\nA snippet function was passed invalid arguments. Snippets should only be instantiated via \\`{@render ...}\\`\\nhttps://svelte.dev/e/invalid_snippet_arguments`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/invalid_snippet_arguments`);\n\t}\n}\n\n/**\n * `%name%(...)` can only be used during component initialisation\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_outside_component(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_outside_component\\n\\`${name}(...)\\` can only be used during component initialisation\\nhttps://svelte.dev/e/lifecycle_outside_component`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/lifecycle_outside_component`);\n\t}\n}\n\n/**\n * Context was not set in a parent component\n * @returns {never}\n */\nexport function missing_context() {\n\tif (DEV) {\n\t\tconst error = new Error(`missing_context\\nContext was not set in a parent component\\nhttps://svelte.dev/e/missing_context`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/missing_context`);\n\t}\n}\n\n/**\n * Attempted to render a snippet without a `{@render}` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change `{snippet}` to `{@render snippet()}`.\n * @returns {never}\n */\nexport function snippet_without_render_tag() {\n\tif (DEV) {\n\t\tconst error = new Error(`snippet_without_render_tag\\nAttempted to render a snippet without a \\`{@render}\\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \\`{snippet}\\` to \\`{@render snippet()}\\`.\\nhttps://svelte.dev/e/snippet_without_render_tag`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/snippet_without_render_tag`);\n\t}\n}\n\n/**\n * `%name%` is not a store with a `subscribe` method\n * @param {string} name\n * @returns {never}\n */\nexport function store_invalid_shape(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`store_invalid_shape\\n\\`${name}\\` is not a store with a \\`subscribe\\` method\\nhttps://svelte.dev/e/store_invalid_shape`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/store_invalid_shape`);\n\t}\n}\n\n/**\n * The `this` prop on `<svelte:element>` must be a string, if defined\n * @returns {never}\n */\nexport function svelte_element_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_element_invalid_this_value\\nThe \\`this\\` prop on \\`<svelte:element>\\` must be a string, if defined\\nhttps://svelte.dev/e/svelte_element_invalid_this_value`);\n\n\t\terror.name = 'Svelte error';\n\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);\n\t}\n}","const ATTR_REGEX = /[&\"<]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * @template V\n * @param {V} value\n * @param {boolean} [is_attr]\n */\nexport function escape_html(value, is_attr) {\n\tconst str = String(value ?? '');\n\n\tconst pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n\tpattern.lastIndex = 0;\n\n\tlet escaped = '';\n\tlet last = 0;\n\n\twhile (pattern.test(str)) {\n\t\tconst i = pattern.lastIndex - 1;\n\t\tconst ch = str[i];\n\t\tescaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '\"' ? '&quot;' : '&lt;');\n\t\tlast = i + 1;\n\t}\n\n\treturn escaped + str.substring(last);\n}\n","/** @import { SSRContext } from '#server' */\nimport { DEV } from 'esm-env';\nimport * as e from './errors.js';\n\n/** @type {SSRContext | null} */\nexport var ssr_context = null;\n\n/** @param {SSRContext | null} v */\nexport function set_ssr_context(v) {\n\tssr_context = v;\n}\n\n/**\n * @template T\n * @returns {[() => T, (context: T) => T]}\n * @since 5.40.0\n */\nexport function createContext() {\n\tconst key = {};\n\treturn [() => getContext(key), (context) => setContext(key, context)];\n}\n\n/**\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\treturn result;\n}\n\n/**\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_or_init_context_map('setContext').set(key, context);\n\treturn context;\n}\n\n/**\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_or_init_context_map('hasContext').has(key);\n}\n\n/** @returns {Map<any, any>} */\nexport function getAllContexts() {\n\treturn get_or_init_context_map('getAllContexts');\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (ssr_context === null) {\n\t\te.lifecycle_outside_component(name);\n\t}\n\n\treturn (ssr_context.c ??= new Map(get_parent_context(ssr_context) || undefined));\n}\n\n/**\n * @param {Function} [fn]\n */\nexport function push(fn) {\n\tssr_context = { p: ssr_context, c: null, r: null };\n\n\tif (DEV) {\n\t\tssr_context.function = fn;\n\t\tssr_context.element = ssr_context.p?.element;\n\t}\n}\n\nexport function pop() {\n\tssr_context = /** @type {SSRContext} */ (ssr_context).p;\n}\n\n/**\n * @param {SSRContext} ssr_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(ssr_context) {\n\tlet parent = ssr_context.p;\n\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\n\treturn null;\n}\n\n/**\n * Wraps an `await` expression in such a way that the component context that was\n * active before the expression evaluated can be reapplied afterwards â€”\n * `await a + b()` becomes `(await $.save(a))() + b()`, meaning `b()` will have access\n * to the context of its component.\n * @template T\n * @param {Promise<T>} promise\n * @returns {Promise<() => T>}\n */\nexport async function save(promise) {\n\tvar previous_context = ssr_context;\n\tvar value = await promise;\n\n\treturn () => {\n\t\tssr_context = previous_context;\n\t\treturn value;\n\t};\n}\n"],"names":["fallback","e.lifecycle_outside_component","ssr_context"],"mappings":"AAEU,IAAC,WAAW,MAAM;AAClB,IAAC,WAAW,MAAM,UAAU;AAC5B,IAAC,aAAa,MAAM;AAEpB,IAAC,kBAAkB,OAAO;AAC1B,IAAC,iBAAiB,OAAO;AAEzB,IAAC,mBAAmB,OAAO;AAC3B,IAAC,kBAAkB,MAAM;AACzB,IAAC,mBAAmB,OAAO;AAC3B,IAAC,gBAAgB,OAAO;AAUtB,MAAC,OAAO,MAAM;AAAC;AAepB,SAAS,IAAI,IAAI;AACvB,SAAO,GAAE;AACV;AAGO,SAAS,QAAQ,KAAK;AAC5B,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,QAAI,CAAC,EAAC;AAAA,EACP;AACD;AAMO,SAAS,WAAW;AAE1B,MAAI;AAGJ,MAAI;AAGJ,MAAI,UAAU,IAAI,QAAQ,CAAC,KAAK,QAAQ;AACvC,cAAU;AACV,aAAS;AAAA,EACV,CAAC;AAGD,SAAO,EAAE,SAAS,SAAS,OAAM;AAClC;AASO,SAAS,SAAS,OAAOA,WAAU,OAAO,OAAO;AACvD,SAAO,UAAU,SACd;AAAA;AAAA,IACyBA,UAAQ;AAAA;AAAA;AAAA,IACdA;AAAA,MACnB;AACJ;ACxBO,SAAS,4BAA4B,MAAM;AAO1C;AACN,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACnE;AACD;ACpEA,MAAM,aAAa;AACnB,MAAM,gBAAgB;AAOf,SAAS,YAAY,OAAO,SAAS;AAC3C,QAAM,MAAM,OAAO,SAAS,EAAE;AAE9B,QAAM,UAAU,UAAU,aAAa;AACvC,UAAQ,YAAY;AAEpB,MAAI,UAAU;AACd,MAAI,OAAO;AAEX,SAAO,QAAQ,KAAK,GAAG,GAAG;AACzB,UAAM,IAAI,QAAQ,YAAY;AAC9B,UAAM,KAAK,IAAI,CAAC;AAChB,eAAW,IAAI,UAAU,MAAM,CAAC,KAAK,OAAO,MAAM,UAAU,OAAO,MAAM,WAAW;AACpF,WAAO,IAAI;AAAA,EACZ;AAEA,SAAO,UAAU,IAAI,UAAU,IAAI;AACpC;ACpBU,IAAC,cAAc;AAGlB,SAAS,gBAAgB,GAAG;AAClC,gBAAc;AACf;AAiBO,SAAS,WAAW,KAAK;AAC/B,QAAM,cAAc,wBAAoC;AACxD,QAAM;AAAA;AAAA,IAA2B,YAAY,IAAI,GAAG;AAAA;AAEpD,SAAO;AACR;AAQO,SAAS,WAAW,KAAK,SAAS;AACxC,0BAAoC,EAAE,IAAI,KAAK,OAAO;AACtD,SAAO;AACR;AAMO,SAAS,WAAW,KAAK;AAC/B,SAAO,wBAAoC,EAAE,IAAI,GAAG;AACrD;AAGO,SAAS,iBAAiB;AAChC,SAAO,wBAAwC;AAChD;AAMA,SAAS,wBAAwB,MAAM;AACtC,MAAI,gBAAgB,MAAM;AACzBC,gCAAkC;AAAA,EACnC;AAEA,SAAQ,YAAY,MAAM,IAAI,IAAI,mBAAmB,WAAW,KAAK,MAAS;AAC/E;AAKO,SAAS,KAAK,IAAI;AACxB,gBAAc,EAAE,GAAG,aAAa,GAAG,MAAM,GAAG,KAAI;AAMjD;AAEO,SAAS,MAAM;AACrB;AAAA,EAAyC,YAAa;AACvD;AAMA,SAAS,mBAAmBC,cAAa;AACxC,MAAI,SAASA,aAAY;AAEzB,SAAO,WAAW,MAAM;AACvB,UAAM,cAAc,OAAO;AAC3B,QAAI,gBAAgB,MAAM;AACzB,aAAO;AAAA,IACR;AACA,aAAS,OAAO;AAAA,EACjB;AAEA,SAAO;AACR;","x_google_ignoreList":[0,1,2,3]}